# create multiple lags for a single time series or within each panel. Does not require dplyr.
multi_lag = function(data,
varname,
nlags,
t_index,
spatunit=NULL,
append=T,
afix = c("L", "."),
suffix = F,
sort = T){
stopifnot(!missing(data), !missing(varname), !missing(nlags), !missing(t_index))
# convert tbl to dataframe for subsetting.
# Could use unname(unlist()) on cols for subsetting instead, but fn returns df anyway, so this conversion is less cumbersome
if(any(c("tbl", "tbl_df") %in% class(data))){
warning("Be aware: `data` input as class ", paste(class(data), collapse =", "), ", but output is data.frame only.", call.=F, immediate. = F)
data=as.data.frame(data)
}
# argument checking
assert(is.character(varname) && length(varname) == 1,
"`varname` must be a character string of length 1.")
assert(all(nlags %% 1 == 0) && is.null(dim(nlags)),
"`nlags` must be an integer valued scalar or vector.")
assert(is.null(spatunit) ||
length(spatunit) == 1 && is.character(spatunit),
"`spatunit` must be a length 1 character string, or NULL.")
assert(is.character(t_index) && length(t_index) == 1,
"`t_index` must be a length 1 character string.")
assert(is.character(afix) && length(afix == 2),
"`afix` must be a length 2 character vector.")
panel = !is.null(spatunit)
assert(panel, type="message", immediate = F,
paste0("Argument `spatunit` not entered. Defaulting to single time series with time variable == ", t_index)
)
# set up data
if(length(nlags) > 1) lag_index = nlags else lag_index = seq_len(nlags)
cat(lag_index, "\n")
if(panel){
check_dups(data, spatunit, t_index)
if(sort) data = data[order(data[,spatunit], data[,t_index]),] #order data within panels
data_tolag = data[,c(spatunit, varname)] # get panel indices
data_split = split(data_tolag, data_tolag[, spatunit]) # split along spatial paneling variable
data_split = lapply(data_split, "[[", varname) # subset the now split data, getting only the dependent variable. Returns list.
# container for lags
lagged=list()
# create nlags sequential lags of varname within panels.
for(i in seq_along(lag_index)){
lagged[[i]]=unlist(lapply(data_split, lagr, laglen=lag_index[i]))
}
} else {
check_dups(data, spatunit=NULL, t_index)
if(sort) data = data[order(data[,t_index]),]
lagged = lapply(lag_index, lagr, x=data[, varname])
}
lag_df = do.call(cbind.data.frame, lagged)
if(!suffix){
varnames = paste0(afix[1], lag_index, afix[2], varname)
}  else varnames = paste0(varname, afix[1], afix[2], lag_index)
colnames(lag_df) = varnames
if(append)
return(cbind.data.frame(data, lag_df))
else
return(lag_df)
}
# check for repeated observations within time-series or panels
check_dups = function(data, spatunit=NULL, t_index){
assert(is.null(spatunit) ||
length(spatunit) == 1 && is.character(spatunit),
"`spatunit` must be a length 1 character string, or NULL.")
assert(is.character(t_index) && length(t_index) == 1,
"`t_index` must be a length 1 character string.")
panel = !is.null(spatunit)
if(!panel){
dups = duplicated(data[, t_index])
} else {
to_check = paste(data[, spatunit], data[, t_index], sep="_") # paste together columns of time and space. Eg, time=1, space=a, result=1a
dups = duplicated(to_check) # check if duplicates in pasted time-space. Returns logical.
}
ndups = sum(dups)
assert(ndups == 0,
paste("Repeated observations within panels or time-series detected at following row numbers:\n\n",
paste(which(dups), collapse=", ")
)
)
}
# create lag of length laglen. Advantage is absence of dplyr
lagr = function(x, laglen){
assert(is.null(dim(x)) && is.atomic(x) && laglen %% 1 == 0, call = T,
"`x` must be a vector and `laglen` must be an integer value.")
nobs = length(x)
if(nobs <= laglen){
lagged = rep(NA, times=nobs)
} else {
lagged = c(rep(NA, laglen), head(x, nobs-laglen))
}
return(lagged)
}
t = 10000
n = 26
space = rep(letters[1:n],  each=t)
df = cbind.data.frame(y=rnorm(n*t), x=rnorm(n*t), space, ti = rep(1:t, n))
df = df[sample(nrow(df)),]
profvis(multi_lag(df, "y", spatunit = "space", t_index = "ti", nlags=c(1,3), afix = c("lag_", "."), suffix = F))
library(profvis)
library(dplyr)
profvis(multi_lag(df, "y", spatunit = "space", t_index = "ti", nlags=c(1,3), afix = c("lag_", "."), suffix = F))
`%!in%` = Negate(`%in%`)
assert = function(cond, expr, call = F, immediate = F, type="error"){
if(length(type) != 1 || !is.character(type) || type %!in% c("error", "warning", "message")){
stop("Argument `type` must be a length 1 string from c(\"error\", \"warning\", \"message\")")
}
if(!cond){
switch(type,
"error" = stop(expr, call. = call),
"warning" = warning(expr, call. = call, immediate. = immediate),
"message" = message(expr, appendLF=T)
)
}
}
profvis(multi_lag(df, "y", spatunit = "space", t_index = "ti", nlags=c(1,3), afix = c("lag_", "."), suffix = F))
profvis(df %>% group_by(space) %>% mutate(lag1 = lag(y, 1, order_by=ti), lag3=lag(y, order_by=ti)) %>% arrange(space, ti))
?vapply
test=multi_lag(df, "y", spatunit = "space", t_index = "ti", nlags=c(1,3), afix = c("lag_", "."), suffix = F)
test2=df %>% group_by(space) %>% mutate(lag1 = lag(y, 1, order_by=ti), lag3=lag(y, order_by=ti)) %>% arrange(space, ti)
View(test2)
View(test)
View(test2)
test2=df %>% group_by(space) %>% mutate(lag1 = lag(y, 1, order_by=ti), lag3=lag(y, 3, order_by=ti)) %>% arrange(space, ti)
View(test2)
t = 100000
n = 26
space = rep(letters[1:n],  each=t)
df = cbind.data.frame(y=rnorm(n*t), x=rnorm(n*t), space, ti = rep(1:t, n))
df = df[sample(nrow(df)),]
test=multi_lag(df, "y", spatunit = "space", t_index = "ti", nlags=c(1,3), afix = c("lag_", "."), suffix = F)
test2=df %>% group_by(space) %>% mutate(lag1 = lag(y, 1, order_by=ti), lag3=lag(y, 3, order_by=ti)) %>% arrange(space, ti)
profvis(multi_lag(df, "y", spatunit = "space", t_index = "ti", nlags=c(1,3), afix = c("lag_", "."), suffix = F))
